# -*- coding: utf-8 -*-
"""BIC_Lab_191-115-100.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Xf70IJuy6wLmwgQdeO46PFvTLKIIMJ-n

**Findig the patterns**
"""

def PatternCount(Text, Pattern):
    count = 0
    for i in range(len(Text)-len(Pattern)+1):
        if Text[i:i+len(Pattern)] == Pattern:
            count = count+1
    return count

Pattern=input()
Text=input()

print(PatternCount(Pattern, Text))

"""**Find the Most Frequent Words in a String**"""

def CountDict(Text, k):
    Count = {}
    for i in range(len(Text)-k+1):
        Pattern = Text[i:i+k]
        Count[i] = PatternCount(Pattern, Text)
    return Count

Text=input()
k=int(input())

print(CountDict(Text, k))

def PatternPos(Pattern, Text):
    pos=[]
    for i in range(len(Text)-len(Pattern)+1):
        if Text[i:i+len(Pattern)] == Pattern:
          pos.append(i)
    return pos

Pattern=input()
Text=input()
a = PatternPos(Pattern, Text)

for i in a:
  print(i, end=" ")

"""**Computing the Hamming distance**"""

def hammingDist(str1, str2):
  i = 0
  count = 0

  while(i<len(str2)):
    if(str1[i] != str2[i]):
        count +=1
    i += 1
  return count

str1=input()
str2=input()

print(hammingDist(str1, str2))

"""**Minimum Skew Problem**"""

def MinimumSkew(s):
	skew = [0]
	for i in range(len(s)):
		if s[i] == "G":
			skew.append(skew[-1]+1)
		elif s[i] == "C":
			skew.append(skew[-1]-1)
		else:
			skew.append(skew[-1])
	
	minimum_skew = min(skew)
	for i in range(len(skew)):
		if skew[i] == minimum_skew:
			print(i, end=" ")
	print()
	return skew

str=input()

MinimumSkew(str)

"""**Find Patterns Forming Clumps in a String (BA1G)**"""

def findClump(string, k, L, t):
  ans = []

  for i in range(len(string)-L+1):
    for j in range(i, i+L-k):
      if string[i:i+L].count(string[j:j+k]) == t:
        ans.append(string[j:j+k])
  ans = list(set(ans))
  return ans

s=input()
k=int(input())
L=int(input())
t=int(input())

ans = findClump(s, k, L, t)
print(" ".join(ans))

"""**Find All Approximate Occurrences of a Pattern(BA1H)**"""

def ApproximatePattern(pattern, text, d):
  positions = []
  for i in range(len(text)-len(pattern)+1):
    if hammingDist(pattern, text[i:i+len(pattern)]) <= d:
      print(i, end=" ")

pattern = input()
text = input()
d = int(input())

ApproximatePattern(pattern, text, d)

"""**Computing a Frequency Array9(BA1K)**"""

def GenerateArray(k):
  bases = ['A', 'C', 'G', 'T']
  array = bases
  for n in range(k-1):
    array = [i+j for i in array for j in bases]
  return array

def ComputeFreq(text, k):
  k_mers = GenerateArray(k)

  for pattern in k_mers:
    print(PatternCount(text, pattern), end=" ")

text = input()
k = int(input())

ComputeFreq(text, k)

"""**Implement PatternToNumber(BA1L) **"""

def PatternToNumber(pattern):
  seq = {'A':0, 'C':1, 'G':2, 'T':3}
  k = len(pattern)
  num = 0

  for i in range(k):
    num += seq[pattern[i]] * pow(4, k-i-1)
  return num

pattern = input()
print(PatternToNumber(pattern))

"""**Implement Number To Pattern(BA1M)**"""

def NumberToPattern(index, k):
  bases = ['A', 'C', 'G', 'T']
  pattern = ''
  for i in range(k):
    pattern += bases[index % 4]
    index = index // 4
  return pattern[::-1]

index = int(input())
k = int(input())

print(NumberToPattern(index, k))